'''
Created on Aug 10, 2018

@author: cjgrady
@todo: Use logger
@todo: Organize imports


@todo: Add code to check outputs
@todo: Alphabetize functions
@todo: Fill in header

@todo: Fill in return from model and projection
@todo: Collect snippets

'''
import os
import shutil
import time
import zipfile

from LmBackend.common.layerTools import processLayersJSON
from LmBackend.common.subprocessManager import SubprocessRunner
from LmBackend.common.metrics import LmMetricNames, LmMetrics
from LmCommon.common.lmconstants import JobStatus, LMFormat
from LmCompute.common.lmObj import LmException
from LmCommon.common.readyfile import readyFilename
from LmCompute.common.log import LmComputeLogger

# .............................................................................
class ModelSoftwareWrapper(object):
   """
   """
   LOGGER_NAME = 'model_tool' # Subclasses should change this
   RETRY_STATUSES = []
   
   # ...................................
   def __init__(self, work_dir, species_name, logger=None):
      self.work_dir = work_dir
      self.metrics = LmMetrics(None)
      self.snippets = []
      self.species_name = species_name
      
      # If work directory does not exist, create it
      if not os.path.exists(self.work_dir):
         os.makedirs(self.work_dir)
      
      if logger is None:
         self.logger = LmComputeLogger(self.LOGGER_NAME, addConsole=True)
   
   # ...................................
   def _build_command(self, tool, option_list):
      """
      @summary: Builds a command to run the tool
      @param tool: Binary (or decorated binary) for the software tool to run
      @param option_list: A list of options to send to the tool
      """
      cmd = '{tool} {options}'.format(tool=tool, options=' '.join(option_list))
      self.logger.debug('Command: "{}"'.format(cmd))
      return cmd
   
   # ...................................
   def _check_projection(self):
      pass
   
   def _check_model(self):
      pass
   def _check_outputs(self):
      pass
   
   # ...................................
   def _process_layers(self, layer_json, layer_dir=None):
      """
      @summary: Read the layer JSON and process the layers accordingly
      @param layer_json: JSON string with layer information
      @param layer_dir: If present, create sym links in the directory to the 
                           layers
      """
      lyrs = processLayersJSON(layer_json, symDir=layer_dir)
      return lyrs
   
   # ...................................
   def _run_tool(self, cmd, num_tries=1):
      """
      @summary: Runs the tool
      @param cmd: The command to run
      @param num_tries: The number of times to try this command
      """
      tries_left = max([num_tries, 1])
      try:
         cont = True
         while cont:
            cont = False
            tries_left -= 1
            spr = SubprocessRunner(cmd)
            start_time = time.time()
            proc_exit_status, proc_std_err = spr.run()
            end_time = time.time()
            self.metrics.add_metric(LmMetricNames.RUNNING_TIME, 
                                                         end_time - start_time)
            status = JobStatus.COMPUTED
            
            if proc_exit_status > 0:
               status = self._find_error(proc_std_err)
               
               if status in self.RETRY_STATUSES:
                  self.logger.debug('Status is: {}, retries left: {}'.format(
                                                         status, tries_left))
                  if tries_left > 0:
                     cont = True
      except LmException, lme:
         status = lme.status
      
      # Get size of output directory
      self.metrics.add_metric(LmMetricNames.OUTPUT_SIZE, 
                                    self.metrics.get_dir_size(self.work_dir))
      self.metrics.add_metric(LmMetricNames.STATUS, status)
   
   # ...................................
   def clean_up(self):
      """
      @summary: Deletes work directory
      """
      shutil.rmtree(self.work_dir)
   
   # ...................................
   def create_model(self, points, layer_json, parameters_json, 
                    mask_filename=None, crs_wkt=None):
      raise Exception, 'Not implemented in base class'
      #mdl_filename, mdl_metrics, mdl_snippets, projection_info
         
   # ...................................
   def create_projection(self, ruleset_filename, layer_json, 
                         parameters_json=None, mask_filename=None):
      raise Exception, 'Not implemented in base class'
   
   # ...................................
   def get_ruleset_filename(self):
      """
      @summary: Return the ruleset filename generated by the model
      """
      raise Exception, 'Not implemented in base class'
   
   # ...................................
   def get_output_package(self, destination_filename, overwrite=False):
      """
      @summary: Write the output package to the specified file location
      @param destination_filename: The location to write the (zipped) package
      @param overwrite: Should the file location be overwritten
      """
      readyFilename(destination_filename, overwrite=overwrite)
      
      with zipfile.ZipFile(destination_filename, 'w', 
                           compression=zipfile.ZIP_DEFLATED, 
                           allowZip64=True) as zf:
         for base, _, files in os.walk(self.work_dir):
            if base.find('layers') == -1: # Skip layers directory
               for f in files:
                  # Don't add zip files
                  if f.find(LMFormat.ZIP.ext) == -1:
                     zf.write(os.path.join(base, f), 
                              os.path.relpath(os.path.join(base, f), 
                                              self.work_dir))

   # ...................................
   def get_log_filename(self):
      """
      @summary: Return the filename for the generated log
      """
      raise Exception, 'Not implemented in base class'
   
   # ...................................
   def get_projection_filename(self):
      """
      @summary: Return the projection raster filename generated
      """
      raise Exception, 'Not implemented in base class'

   # ...................................
   def get_status(self):
      """
      @summary: Return the status of the model
      """
      try:
         return self.metrics[LmMetricNames.STATUS]
      except:
         return None

   # ...................................
   def _copy_file(self, source_filename, destination_filename, 
                                                            overwrite=False):
      """
      @summary: Copy source file to destination and prepare location if 
                   necessary
      @param source_filename: The source file
      @param destination_filename: The destination for the file
      @param overwrite: Should the file location be overwritten 
      """
      if os.path.exists(source_filename):
         readyFilename(destination_filename, overwrite=overwrite)
         shutil.copy(source_filename, destination_filename)
      else:
         raise IOError, '{} does not exist'.format(source_filename)
      
   # ...................................
   def copy_ruleset(self, destination_filename, overwrite=False):
      """
      @summary: Copy the ruleset to the specified destination
      @param destination_filename: The destination for the file
      @param overwrite: Should the file location be overwritten 
      """
      self._copy_file(self.get_ruleset_filename(), destination_filename, 
                      overwrite=overwrite)
   
   # ...................................
   def copy_projection(self, destination_filename, overwrite=False):
      """
      @summary: Copy the projection raster to the specified destination
      @param destination_filename: The destination for the file
      @param overwrite: Should the file location be overwritten 
      """
      self._copy_file(self.get_projection_filename(), destination_filename, 
                      overwrite=overwrite)
   # ...................................
   def copy_log_file(self, destination_filename, overwrite=False):
      """
      @summary: Copy the log to the specified destination
      @param destination_filename: The destination for the file
      @param overwrite: Should the file location be overwritten 
      """
      self._copy_file(self.get_log_filename(), destination_filename, 
                      overwrite=overwrite)
   